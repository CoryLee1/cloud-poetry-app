<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8" />
    <link rel="stylesheet" href="globals.css" />
    <link rel="stylesheet" href="styleguide.css" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="screen" data-model-id="43:3828">
      <div class="overlap-wrapper">
        <div class="overlap">
          <!-- Three.js Canvas 最底层背景 -->
          <canvas id="three-canvas" class="cloud-layer"></canvas>
          
          <!-- UI层 - 在Three.js之上 -->
          <img class="vector" src="img/vector-3212.svg" />
          <img class="img" src="img/vector-3213.svg" />
          <div class="home-indicator"><div class="div"></div></div>
          <div class="frame">
            <div class="frame-2">
              <div class="HI-IVY">HI~</div>
              <div class="text-wrapper">今天心情怎么样?</div>
            </div>
            <div class="element">
              你来啦! 今天想和我说什么呢?<br />哦对了!今天上海的太阳落下时间是18:34分<br />可以放下繁琐,抽点时间看看夕阳~
            </div>
          </div>
          <div class="frame-3">
            <div class="status-bar">
              <div class="left-side">
                <div class="statusbar-time"><div class="time">9:41</div></div>
              </div>
              <div class="dynamic-island">
                <div class="statusbar">
                  <div class="truedepth-camera"></div>
                  <div class="facetime-camera"></div>
                </div>
              </div>
              <div class="right-side">
                <div class="signal-wifi-battery">
                  <img class="icon-mobile-signal" src="img/icon-mobile-signal.svg" />
                  <img class="wifi" src="img/wifi.svg" />
                  <img class="statusbar-battery" src="img/statusbar-battery.svg" />
                </div>
              </div>
            </div>
            <div class="frame-4">
              <div class="frame-5">
                <img class="vector-2" src="img/vector.svg" /> <img class="vector-3" src="img/vector-1.svg" />
              </div>
              <div class="element-2">7月21日&nbsp;&nbsp;｜ 上海 小雨</div>
              <div class="frame-5">
                <div class="overlap-group">
                  <div class="rectangle"></div>
                  <img class="vector-4" src="img/vector-13.svg" />
                  <img class="vector-5" src="img/vector-15.svg" />
                  <img class="vector-6" src="img/vector-15.svg" />
                  <img class="vector-7" src="img/vector-13.svg" />
                </div>
              </div>
            </div>
          </div>
          <div class="frame-6">
            <div class="frame-7">
              <input 
                type="text" 
                class="text-wrapper-2 input-field" 
                placeholder="现在的你，是什么感觉呢？" 
                value=""
              />
            </div>
            <div class="view">
              <img class="vector-8" src="img/vector-2.svg" />
              <img class="vector-9" src="img/vector-3.svg" />
              <img class="vector-10" src="img/vector-4.svg" />
              <img class="vector-11" src="img/vector-5.svg" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./src/utils/build/three.module.js",
                "three/addons/": "./src/utils/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from './src/utils/jsm/controls/OrbitControls.js';
        import { ImprovedNoise } from './src/utils/jsm/math/ImprovedNoise.js';

        let renderer, scene, camera;
        let mesh;

        init();

        function init() {
            // Three.js 初始化
            const canvas = document.getElementById('three-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                alpha: true,
                antialias: true,
                preserveDrawingBuffer: false
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(375, 801);
            renderer.setAnimationLoop(animate);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(60, 375 / 801, 0.1, 100);
            camera.position.set(0, 0, 1.5);

            // 添加OrbitControls - 让云朵可以交互
            const controls = new OrbitControls(camera, canvas);
            controls.enableZoom = false; // 禁用缩放
            controls.enablePan = false;  // 禁用平移
            controls.enableDamping = true; // 启用阻尼效果
            controls.dampingFactor = 0.05;

            // 添加天空球
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 1;
            skyCanvas.height = 32;

            const context = skyCanvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 32);
            gradient.addColorStop(0.0, '#014a84');
            gradient.addColorStop(0.5, '#0561a0');
            gradient.addColorStop(1.0, '#437ab6');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 1, 32);

            const skyMap = new THREE.CanvasTexture(skyCanvas);
            skyMap.colorSpace = THREE.SRGBColorSpace;

            const sky = new THREE.Mesh(
                new THREE.SphereGeometry(10),
                new THREE.MeshBasicMaterial({ map: skyMap, side: THREE.BackSide })
            );
            scene.add(sky);

            // 创建云朵纹理
            const size = 128;
            const data = new Uint8Array(size * size * size);

            let i = 0;
            const scale = 0.05;
            const perlin = new ImprovedNoise();
            const vector = new THREE.Vector3();

            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const d = 1.0 - vector.set(x, y, z).subScalar(size / 2).divideScalar(size).length();
                        data[i] = (128 + 128 * perlin.noise(x * scale / 1.5, y * scale, z * scale / 1.5)) * d * d;
                        i++;
                    }
                }
            }

            const texture = new THREE.Data3DTexture(data, size, size, size);
            texture.format = THREE.RedFormat;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.unpackAlignment = 1;
            texture.needsUpdate = true;

            // 着色器代码
            const vertexShader = /* glsl */`
                in vec3 position;
                uniform mat4 modelMatrix;
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform vec3 cameraPos;
                out vec3 vOrigin;
                out vec3 vDirection;

                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vOrigin = vec3(inverse(modelMatrix) * vec4(cameraPos, 1.0)).xyz;
                    vDirection = position - vOrigin;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = /* glsl */`
                precision highp float;
                precision highp sampler3D;

                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;

                in vec3 vOrigin;
                in vec3 vDirection;

                out vec4 color;

                uniform vec3 base;
                uniform sampler3D map;

                uniform float threshold;
                uniform float range;
                uniform float opacity;
                uniform float steps;
                uniform float frame;

                uint wang_hash(uint seed) {
                    seed = (seed ^ 61u) ^ (seed >> 16u);
                    seed *= 9u;
                    seed = seed ^ (seed >> 4u);
                    seed *= 0x27d4eb2du;
                    seed = seed ^ (seed >> 15u);
                    return seed;
                }

                float randomFloat(inout uint seed) {
                    return float(wang_hash(seed)) / 4294967296.;
                }

                vec2 hitBox(vec3 orig, vec3 dir) {
                    const vec3 box_min = vec3(-0.5);
                    const vec3 box_max = vec3(0.5);
                    vec3 inv_dir = 1.0 / dir;
                    vec3 tmin_tmp = (box_min - orig) * inv_dir;
                    vec3 tmax_tmp = (box_max - orig) * inv_dir;
                    vec3 tmin = min(tmin_tmp, tmax_tmp);
                    vec3 tmax = max(tmin_tmp, tmax_tmp);
                    float t0 = max(tmin.x, max(tmin.y, tmin.z));
                    float t1 = min(tmax.x, min(tmax.y, tmax.z));
                    return vec2(t0, t1);
                }

                float sample1(vec3 p) {
                    return texture(map, p).r;
                }

                float shading(vec3 coord) {
                    float step = 0.01;
                    return sample1(coord + vec3(-step)) - sample1(coord + vec3(step));
                }

                vec4 linearToSRGB(in vec4 value) {
                    return vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);
                }

                void main() {
                    vec3 rayDir = normalize(vDirection);
                    vec2 bounds = hitBox(vOrigin, rayDir);

                    if (bounds.x > bounds.y) discard;

                    bounds.x = max(bounds.x, 0.0);

                    vec3 p = vOrigin + bounds.x * rayDir;
                    vec3 inc = 1.0 / abs(rayDir);
                    float delta = min(inc.x, min(inc.y, inc.z));
                    delta /= steps;

                    uint seed = uint(gl_FragCoord.x) * uint(1973) + uint(gl_FragCoord.y) * uint(9277) + uint(frame) * uint(26699);
                    vec3 size = vec3(textureSize(map, 0));
                    float randNum = randomFloat(seed) * 2.0 - 1.0;
                    p += rayDir * randNum * (1.0 / size);

                    vec4 ac = vec4(base, 0.0);

                    for (float t = bounds.x; t < bounds.y; t += delta) {
                        float d = sample1(p + 0.5);
                        d = smoothstep(threshold - range, threshold + range, d) * opacity;
                        float col = shading(p + 0.5) * 3.0 + ((p.x + p.y) * 0.25) + 0.2;
                        ac.rgb += (1.0 - ac.a) * d * col;
                        ac.a += (1.0 - ac.a) * d;
                        if (ac.a >= 0.95) break;
                        p += rayDir * delta;
                    }

                    color = linearToSRGB(ac);
                    if (color.a == 0.0) discard;
                }
            `;

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.RawShaderMaterial({
                glslVersion: THREE.GLSL3,
                uniforms: {
                    base: { value: new THREE.Color(0x798aa0) },
                    map: { value: texture },
                    cameraPos: { value: new THREE.Vector3() },
                    threshold: { value: 0.25 },
                    opacity: { value: 0.25 },
                    range: { value: 0.1 },
                    steps: { value: 100 },
                    frame: { value: 0 }
                },
                vertexShader,
                fragmentShader,
                side: THREE.BackSide,
                transparent: true
            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
        }

        function animate() {
            mesh.material.uniforms.cameraPos.value.copy(camera.position);
            mesh.rotation.y = -performance.now() / 7500;
            mesh.material.uniforms.frame.value++;
            renderer.render(scene, camera);
        }
    </script>

    <!-- API交互脚本 -->
    <script>
        // 获取元素
        const inputField = document.querySelector('.input-field');
        const voiceButton = document.querySelector('.view');
        let mediaRecorder = null;
        let audioChunks = [];

        // 文本输入处理
        inputField.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const mood = inputField.value.trim();
                if (mood) {
                    await generatePoetry(mood);
                }
            }
        });

        // 语音按钮处理
        voiceButton.addEventListener('click', async () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // 停止录音
                mediaRecorder.stop();
                voiceButton.style.backgroundColor = '#000000';
            } else {
                // 开始录音
                await startRecording();
                voiceButton.style.backgroundColor = '#ff4444';
            }
        });

        // 生成诗歌
        async function generatePoetry(mood) {
            try {
                console.log('正在生成诗歌...', mood);
                
                const response = await fetch('/api/generate-poetry', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ mood })
                });

                const data = await response.json();
                
                if (data.success) {
                    console.log('诗歌生成成功:', data.poetry);
                    // 这里可以显示诗歌，或者进入游戏模式
                    alert(`诗歌生成成功！\n\n${data.poetry}`);
                } else {
                    console.error('生成诗歌失败:', data.error);
                    alert('生成诗歌失败: ' + data.error);
                }
            } catch (error) {
                console.error('API调用错误:', error);
                alert('网络错误，请重试');
            }
        }

        // 开始录音
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    await sendAudioToServer(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                console.log('开始录音...');
            } catch (error) {
                console.error('录音失败:', error);
                alert('无法访问麦克风，请检查权限设置');
            }
        }

        // 发送音频到服务器
        async function sendAudioToServer(audioBlob) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.wav');

                const response = await fetch('/api/speech-to-text', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                
                if (data.success) {
                    console.log('语音识别成功:', data.text);
                    inputField.value = data.text;
                    // 自动生成诗歌
                    await generatePoetry(data.text);
                } else {
                    console.error('语音识别失败:', data.error);
                    alert('语音识别失败: ' + data.error);
                }
            } catch (error) {
                console.error('发送音频失败:', error);
                alert('网络错误，请重试');
            }
        }
    </script>
  </body>
</html> 